# Коллекции Java

## Коллекции, реализующие интерфейс List {collapsible="true"}

Интерфейс List в Java представляет собой упорядоченную коллекцию, позволяющую доступ как по индексу, так и по значению,
и допускающую наличие повторяющихся элементов. Существует несколько реализаций List, основными из которых являются
**ArrayList** и **LinkedList**.

`ArrayList` – это динамический массив, позволяющий хранить null-элементы. Основная структура основана на обычном
массиве, поэтому иногда его описывают как "resizable array". Как и у обычного массива, сложность операций получения
элементов из ArrayList - (O(1)). Это реализуется благодаря тому, что область хранения элементов массива непрерывна, а
размер элемента фиксирован (ссылки занимают 8 байт для 64-битной архитектуры и 4 байта для 32-битной). Таким образом,
зная начальную ячейку массива, достаточно прибавить к ней (n * M) байт, где n - индекс элемента массива, начиная с 0,
M - количество памяти в байтах, занимаемое хранимым типом данных.
[Видеоурок: Внутреннее строение ArrayList](https://www.youtube.com/watch?v=O7wF-chC-ms&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=2)

Операция добавления в конец списка имеет сложность (O(1)), добавление в начало занимает (O(n)) из-за необходимости
перемещения всех последующих элементов. При добавлении элементов также периодически приходится расширять массив, когда
он переполняется, и эта операция формально стоит O(n), хотя и используется очень эффективная функция System.arraycopy.
Но так как расширение производится в полтора раза(int newCapacity = oldCapacity + (oldCapacity >>1);), то общее
количество таких расширений - логарифм, то есть пренебрежимо мало по сравнению с O(n), поэтому в среднем сложность O(1).

`LinkedList` – еще одна реализация List, которая принимает любые данные, включая null-значения. Ее особенность
заключается в двунаправленной структуре связанного списка, где каждый элемент содержит ссылки на предыдущий и следующий
элементы. Операции в начале или конце списка выполняются за постоянное время (O(1)), благодаря возможности перехода к
следующему / предыдущему элементу с начала или конца списка. По той же причине доступ к элементам по индексу или
значению из середины списка занимают линейное время (O(n)). Несмотря на то, что при определенных случаях LinkedList
может быть эффективнее ArrayList, большое количество оптимизаций и общий механизм работы делают ArrayList значительно
более универсальным и распространенным.
[Видеоурок: Подробнее про LinkedList](https://www.youtube.com/watch?v=zEBMKVycvik&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=7)

Также интерфейс List имеет реализации `Vector` и `Stack`, являющиеся устаревшими и не рекомендованные для
применения. `Vector`представляет собой динамический массив, являясь при этом синхронизированной коллекцией, что
позволяет использовать ее в многопоточной среде. Это отрицательно сказывается на производительности при его применении,
а в случае необходимости использовать многопоточные коллекции стоит обратиться к реализациям из пакета
**java.concurrent**. `Stack`, расширяющий Vector, был введен для реализации стека LIFO (Last in - first out). Хотя он
частично синхронизирован, он стал менее предпочтительным после появления интерфейса Deque в Java 1.6.
[Видеоурок: Класс Vector](https://www.youtube.com/watch?v=XpGR6zEhhSc&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=11)
[Видеоурок: Класс Stack](https://www.youtube.com/watch?v=cvJyy1jMOv0&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=12)

## Коллекции, реализующие интерфейс Map. Хэширование {collapsible="true"}

Интерфейс `Map` находится в составе JDK c версии 1.2 и предоставляет базовые методы для работы с данными вида
«ключ — значение». Также как и `Collection`, он был дополнен дженериками в версии Java 1.5, а в версии Java 8 появились
дополнительные методы для работы с лямбдами. Данный интерфейс реализуют такие коллекции как `HashMap`, `HashTable`,
`LinkedHashMap`, `TreeMap`, `WeakHashMap` и другие.

Одной из самых распространенных коллекций, реализующих `Map` является `HashMap`. В своей основе она содержит массив
`Bucket`, хранящий внутри себя связанный список `Node`. Перед рассмотрением `Bucket`, стоит взглянуть на `Node`.

`Node` имеет следующий вид:

``` 
class Node<K,V> {
    int hash;   
    K key;
    V value;
    Node<K,V> next; 
}
```

Данный класс параметризован значениями `K` и `V`, представляющими собой ключ и значение. Он также имеет ссылку на
следующий узел в пределах одной корзины (о ней чуть позже). Поле hash хранит хеш-код текущего элемента, полученный в
результате хеширования ключа.

**Хеширование** - это процесс преобразования входных данных произвольной длины в фиксированный набор битов определенной
длины. Для корректного хеширования тип данных, используемый в качестве ключа для экземпляра HashMap должен
переопределить метод `hashCode()`, определенный в `Object`. Также важно соблюдать контракт между методами `equals()` и
`hashCode`, а именно:

1) Два объекта, для которых `equals()` возвращает false могут иметь одинакоый хеш. Это явление называется *коллизией*.
2) Два объекта, для которых `equals()` возвращает true обязаны иметь одинаковый хеш-код.
3) Два объекта, для которых `hashCode()` возвращает разный хеш-код не могут быть равны.

Подробнее об этом можно почитать здесь:
[Контракты equals и hashCode или как оно все там](https://javarush.com/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam)
[Видеоурок: Методы equals и hashCode](https://www.youtube.com/watch?v=NQdwRwbPVCs&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=14)

Алгоритм добавления элемента в HashMap выглядит следующим образом:

1) При вызове метода `.put(O obj)` для аргумента `obj` вычисляется хеш-код и в зависимости от него для элемента
   подбирается соответствующий `Bucket`. Посколько диапазон значений хеш-кода элементов огромен и массив такого размера
   создать невозможно/нерационально, хеш-код элемента сжимается до предела количества `Bucket` у данной `HashMap`.
   Сложность данной операции - O(1), так как и вычисление хеш-кода и получение `Bucket` (хранящихся в массиве)
   константны.
2) Создается объект `Node`, хранящий `Key` и `Value` элемента.
3) Если текущий `Bucket` свободен, новосозданный `Node` помещается в него.
4) Если в данном `Bucket` уже есть элемент, значения `equals()` и `hashCode` сравниваются.
5) Если элементы равны - текущее значение `Value` заменяется новым.
6) Если это разные объекты - новый `Node` занимает свою позицию в списке после прошлого элемента и указывает в своем
   поле `next` ссылку на следующий элемент.

Когда элементов в связанном списке для одного из `Bucket` становится много и сложность итерации по ним O(n) становится
дорогой, происходит переход к сбалансированным деревьям, улучшающим эффективность алгоритма до O(log(n)).

Процедура получения элемента по ключу выглядит следующим образом:

1) При вызове метода `.get(K key)` для аргумента `key` вычисляется хеш-код и дальнейшие поиск происходит в
   соответствующей корзине:
2) Список элементов `Bucket` итерируется, сравнивая значения `equals()` и `hashCode` для двух ключей.
3) При нахождении равных ключей, возвращается значение `Value`.
4) В противном случае возвращается `null`.

Таким образом, обладая сложностью получения добавления элемента в среднем O(1), (O(n) в худшем до перебалансировки и
O(log(n)) после неё), HashMap позволяет эффективно хранить элементы в формате ключ-значение.
[Видеоурок: Класс HashMap в деталях](https://www.youtube.com/watch?v=qlVF2RErvEU&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=15)

`HashTable` - реализация `Map`, похожая на `HashMap` с аналогичными процедурами получения и добавления элементов.
Однако, `HashTable` - синхронизированная потокобезопасная коллекция, что отрицательно сказывается на производительности.
По аналогии с `Vector` использование `HashTable` не рекомендуется. Взамен стоит рассмотреть реализации из пакета
**java.concurrent**, например, **ConcurrentHashMap**.
[Видеоурок: Класс HashTable](https://www.youtube.com/watch?v=9hoq5gRb9hE&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=19)

`TreeMap` реализует интерфейс `SortedMap` и использует структуру красно-черного дерева для хранения элементов. В отличие
от `HashMap` и `HashTable`, где элементы не упорядочены, `TreeMap` хранит элементы в отсортированном порядке на основе
ключей.

При добавлении элемента в `TreeMap`, он автоматически сортируется по ключу. Это делает операции вставки и поиска
сложностью O(log(n)) в среднем случае, что делает `TreeMap` эффективным для поиска, удаления и обхода элементов в
отсортированном порядке. Однако, операции добавления и поиска могут быть медленнее, чем в `HashMap` и `HashTable`, из-за
необходимости поддержания сбалансированности дерева.
[Видеоурок: Класс Vector](https://www.youtube.com/watch?v=u-ilAwbJWYc&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=17)

Одной из интересных коллекций, реализующей данный интерфейс является также `LinkedHashMap`. Её особенность в том, что
каждый вставленный элемент имеет ссылку на предыдущий и на следующий элемент, образуя, тем самым, двунаправленный
связанный список. При помощи boolean-параметра `accessOrder`, передаваемого в конструктор, можно указывать, каким
образом будет осуществляться доступ к элементам при использовании итератора: по порядку последнего доступа (при
значении true) или в том порядке, в котором элементы были вставлены (при значении false - по умолчанию). Однако, наличие
дополнительных ссылок на элементы и необходимость дополнительных операций при вставке и получении элементов приводят к
большим затратам памяти и меньшей эффективности данной коллекции, что несколько ограничивает область её применения.
[Видеоурок: Класс Vector](https://www.youtube.com/watch?v=lH-Stxa8zQ8&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=18)

## Коллекции, реализующие интерфейс Set {collapsible="true"}

Интерфейс `Set`, присутствующий в JDK с версии 1.2, представляет собой неупорядоченную коллекцию, которая не может
содержать дублирующиеся данные. Она является программной моделью математического понятия «множество». Интерфейс Set
расширяет интерфейс Collection и добавляет в него несколько методов, таких как методы проверки наличия элемента в
множестве и методы добавления и удаления элементов из множества. Основные реализации Set - `HashSet` и наследующий его
`LinkedHashSet`, а также `TreeSet`, имеющий иерархию предков NavigableSet -> SortedSet -> Set.

`HashSet` является несложным для понимания, если разобраться в принципе работы HashMap. По сути, HashSet базируется на
HashMap и использует внутри себя объект HashMap, а также объект-пустышку (new Object()). В качестве ключа используется
добавляемый элемент, а в качестве значения - объект-пустышка. HashSet не гарантирует порядок хранения элементов внутри
себя. Данная коллекция сопоставима с HashMap по эффективности и основным их отличием является хранение уникальных
элементов у HashSet.
[Видеоурок: Интерфейс Set и класс HashSet](https://www.youtube.com/watch?v=Gn5b3WDbSUE&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=20)

`TreeSet` имеет в своей основе структуру данных "Красно-черное дерево". Он не хранит порядок добавления элементов, но
после каждой вставки и удаления элемента автоматически перебалансирует элементы внутри, поддерживая их в отсортированном
порядке. Для элементов, добавляемых в TreeSet реализация методов equals и hashCode не является критической, так как
благодаря своей структуре, TreeSet для получения элемента осуществляет бинарный поиск.
[Видеоурок: Класс TreeSet](https://www.youtube.com/watch?v=P-fcrskPf8U&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=21)

`LinkedHashSet` отличается от HashSet только тем, что в основе лежит LinkedHashMap вместо HashMap. Благодаря этому
отличию порядок элементов при обходе коллекции является идентичным порядку добавления элементов. За это LinkedHashSet,
как и LinkedHashMap платит меньшей эффективностью и большим затратам памяти.
[Видеоурок: Класс LinkedHashSet](https://www.youtube.com/watch?v=45HObmaFxHc&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=22)

Таким образом, для типа данных, хранимого внутри экземпляра TreeSet важным является реализация интерфейса Comparable и
его метода `compareTo(T o)`, позволяющего сравнивать объект с другим объектом и возвращать значение, соответствующее
результату (отрицательное число; ноль; или положительное число, в случае если объект, на котором вызван метод, меньше;
равен; или больше передаваемого как аргумент метода объекта). Альтернативой реализации данного интерфейса является
передача в конструктор TreeSet объекта типа Comparator, применяемого обычно для реализации неествественной (unnatural)
или внешней сортировки. Comparator представляет собой функциональный интерфейс, так что в конструктор TreeSet его можно
передать как лямбда-выражение, представляющее реализацию анонимного класса с переопределенным методом
`compare(Object o1, Object o2)`. Пример:

```
Set<String> s = new TreeSet<>(new Comparator<String>() {
			@Override
			public int compare(String s1, String s2) {
				return s1.length() - s2.length();
			}
		});
```

Аналогичен:

```
Set<String> s = new TreeSet<>((o1, o2) -> o1.length() - o2.length());
```

В свою очередь аналогичен:

```
Set<String> treeSet = new TreeSet<>(Comparator.comparing(String::length));
```

## Коллекции, реализующие интерфейс Queue {collapsible="true"}

Интерфейс `Queue` появился в JDK в версии 1.5 и представляет собой реализацию очереди FIFO. Помимо методов, определённых
в интерфейсе Collection, он определяет дополнительные методы для извлечения и добавления элементов в очередь. Большая
часть его реализаций находится в пакете java.concurrent и служит для работы в многопоточной среде. Его две основные
реализации вне многопоточной среды: `PriorityQueue` и `ArrayDeque`.

`PriorityQueue` — является единственной прямой реализацией интерфейса Queue (была добавлена, как и интерфейс Queue, в
Java 1.5), не считая класса LinkedList, который так же реализует этот интерфейс, но был реализован намного раньше.
Особенностью данной очереди является возможность управления порядком элементов. По-умолчанию, элементы сортируются с
использованием естественной сортировки (natural ordering), но это поведение может быть переопределено при помощи объекта
Comparator, который задаётся при создании очереди. Данная коллекция не поддерживает null в качестве элементов.
[Видеоурок: Класс PriorityQueue](https://www.youtube.com/watch?v=B_W9P-6Esbk&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=24)

Операции добавления и удаления элементов в PriorityQueue имеют временную сложность в худшем случае O(log n), где n -
количество элементов в очереди, что является достаточно эффективным. При добавлении элемента в PriorityQueue, внутренняя
структура данных поддерживает так называемую "пирамидальную" (heap) структуру, где каждый элемент имеет приоритет
относительно своих потомков. Это обеспечивает быстрое извлечение элемента с наивысшим приоритетом. Операции доступа к
элементам, такие как получение первого элемента (с наивысшим приоритетом), выполняются за константное время O(1). Это
обеспечивает эффективность применения данной очереди в тех случаях, где важно быстрое получение приоритетных элементов
(например, определённые реализации кэша типа MRU - Most Recently Used), хотя тут важно отметить, что производительность
данной коллекции всё ещё далека от желаемой для реализации подобных задач.

`ArrayDeque` — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать
конструкцию вида LIFO (last-in-first-out). Интерфейс Deque и реализация ArrayDeque были добавлены в Java 1.6. Эта
коллекция представляет собой реализацию с использованием массивов, подобно ArrayList, но не позволяет обращаться к
элементам по индексу и хранение null. Как заявлено в документации, коллекция работает быстрее чем Stack, если
используется как LIFO коллекция, а также быстрее чем LinkedList, если используется как FIFO.
[Видеоурок: Введение в Deque и класс ArrayDeque](https://www.youtube.com/watch?v=XhAlbdOAyO8&list=PLqj7-hRTFl_oDMBjI_EstsFcDAwt-Arhs&index=25)

Основной особенностью ArrayDeque является его реализация с использованием динамического массива, подобного ArrayList.
Однако, в отличие от ArrayList, ArrayDeque не позволяет обращаться к элементам по индексу, предоставляя вместо этого
методы для добавления и удаления элементов как в начале, так и в конце коллекции. Операции добавления и удаления
элементов в ArrayDeque выполняются за константное время (O(1)), что делает его эффективным выбором для динамических
структур данных. Как и у ArrayList динамическое изменение размера массива занимает некоторое время, но это лишь
незначительно отражается на эффективности методов коллекции.

## Дополнительный материал

Подробнее о коллекциях Java как о структурах данных можно почитать здесь:
[Справочник по Java Collections Framework](https://habr.com/ru/articles/237043/)
