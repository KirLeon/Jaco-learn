# Клиент-серверная архитектура

Клиент-сервер - вычислительная или сетевая архитектура, в которой задания или сетевая нагрузка распределены между
поставщиками услуг, называемыми серверами, и заказчиками услуг, называемыми клиентами. Фактически клиент и сервер - это
программное обеспечение. Обычно эти программы расположены на разных вычислительных машинах и взаимодействуют между собой
через вычислительную сеть посредством сетевых протоколов, но они могут быть расположены также и на одной машине.
Программы-серверы ожидают от клиентских программ запросы и предоставляют им свои ресурсы в виде:

* данных (например, загрузка файлов посредством HTTP, FTP, BitTorrent, потоковое мультимедиа или работа с базами
  данных);
* сервисных функций (например, работа с электронной почтой, общение посредством систем мгновенного обмена сообщениями
  или
  просмотр web-страниц во всемирной паутине).

Поскольку одна программа-сервер может выполнять запросы от множества программ-клиентов, ее размещают на специально
выделенной вычислительной машине, настроенной особым образом, как правило, совместно с другими программами-серверами,
поэтому производительность этой машины должна быть высокой. Из-за особой роли такой машины в сети, специфики ее
оборудования и программного обеспечения, её также называют сервером, а машины, выполняющие клиентские программы,
соответственно, клиентами.

Архитектуру «клиент-сервер» принято разделять на три класса: одно-, двух- и трехуровневую. Однако, нельзя сказать, что в
вопросе о таком разделении в сообществе ИТ-специалистов существует полный консенсус. Многие называют одноуровневую
архитектуру двухуровневой и наоборот, то же можно сказать о соотношении двух- и трёхуровневой архитектур. Далее будет
рассмотрена трехуровневая архитектура.

![3layersarch.png](3layersarch.png)

## HTTP-протокол {id="http", collapsible="true"}

Изначально HTTP задумывался как протокол передачи HTML-страниц. Долгое время так и было, но сейчас программисты
частенько передают по нему и строки, и медиафайлы. В общем, этот протокол универсальный и гибкий, и использовать его
действительно просто.

Структура HTTP
Сразу стоит отметить, что HTTP-протокол состоит только из текста. Каждое сообщение состоит из трех частей:

1. Стартовая строка (Starting line) — определяет служебные данные.
2. Заголовки (Headers) — описание параметров сообщения.
3. Тело сообщения (Body) — данные сообщения. Должны отделяться от заголовков пустой строкой.

По HTTP-протоколу можно отправить запрос на сервер (request) и получить ответ от сервера (response). Запросы и ответы
немного отличаются параметрами.

Пример простого HTTP-запроса:

```
GET / HTTP/1.1
Host: javarush.com
User-Agent: firefox/5.0 (Linux; Debian 5.0.8; en-US; rv:1.8.1.7)
```

В стартовой строке указаны:
`GET` — метод запроса;
`/` — путь запроса (path);
`HTTP/1.1` — версия протокола передачи данных.
Затем следуют заголовки:
`Host` — хост, которому адресован запрос;
`User-Agent` — клиент, который отправляет запрос.

Тело сообщения в запросах типа `GET`, как правило, отсутствует.

В HTTP-запросе обязательны только стартовая строка и заголовок Host.

## Методы HTTP {id="methods", collapsible="true"}

HTTP-запрос должен содержать метод. Всего их девять: GET, POST, PUT, OPTIONS, HEAD, PATCH, DELETE, TRACE, CONNECT.
Самые распространенные — GET и POST. Кроме того, можно добавлять пользовательские методы, при условии, что и клиентская,
и серверная сторона их различают и умеют обрабатывать.

`GET` — запрашивает контент из сервера. Поэтому у запросов с методом `GET` нет тела сообщения. Но при необходимости
можно отправить параметры через path в таком формате:

https://url/path/something/?name1=value1&name2=value2

Здесь:
url — хост,
/path/something — путь запроса,
? — разделитель, обозначающий, что дальше следуют параметры запроса.

В конце перечисляются параметры в формате ключ=значение, разделенные амперсандом.

`POST` — публикует информацию на сервере. POST-запрос может передавать разную информацию: параметры в формате
ключ=значение, JSON, HTML-код или даже файлы. Вся информация передается в теле сообщения.

Например:

```POST /user/create/json HTTP/1.1
Accept: application/json
Content-Type: application/json
Content-Length: 28
Host: javarush.com

{
"Id": 12345,
"User": "John"
}
```

Запрос отправляется по адресу javarush.com/user/create/json, версия протокола — HTTP/1.1. Accept указывает, какой формат
ответа клиент ожидает получить, Content-Type — в каком формате отправляется тело сообщения. Content-Length — количество
символов в теле.

HTTP-запрос может содержать много разных заголовков. Подробнее с ними можно ознакомиться в спецификации протокола.

## HTTP-ответы {id="responses", collapsible="true"}

После получения запроса, сервер его обрабатывает и отправляет ответ клиенту:

```HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 98

<html>
  <head>
    <title>An Example Page</title>
  </head>
  <body>
    <p>Hello World</p>
  </body>
</html>
```

Стартовая строка в респонсе содержит версию протокола (HTTP/1.1), Код статуса (200), Описание статуса (OK). В
заголовках — тип и длина контента. В теле ответа — HTML-код, который браузер прорисует в HTML-страницу.
Response Status Codes
С телом сообщения и заголовками все ясно, а о кодах статусов стоит сказать пару слов. Response Status Codes всегда
трехзначные, и первая цифра кода указывает категорию ответа:

* 1xx — информационный. Запрос получен, сервер готов к продолжению;
* 2xx — успешный. Запрос получен, понятен и обработан;
* 3xx — перенаправление. Следующие действия нужно выполнить для обработки запроса;
* 4xx — ошибка клиента. Запрос содержит ошибки или не отвечает протоколу;
* 5xx — ошибка сервера. Сервер не смог обработать запрос, хотя был составлен верно;
  Вторая и третья цифры в коде детализируют ответ.

Например:

* 200 OK — реквест получен и успешно обработан;
* 201 Created — реквест получен и успешно обработан, в результате чего создан новый ресурс или его экземпляр;
* 301 Moved Permanently — запрашиваемый ресурс был перемещен навсегда, и последующие запросы к нему должны происходить
  по новому адресу;
* 307 Temporary Redirect — ресурс перемещен временно. Пока к нему можно обращаться, используя автоматическую
  переадресацию;
* 403 Forbidden — запрос понятен, но нужна авторизация;
* 404 Not Found — сервер не нашел ресурс по этому адресу;
* 501 Not Implemented — сервер не поддерживает функциональность для ответа на этот запрос;
* 505 HTTP Version Not Supported — сервер не поддерживает указанную версию HTTP-протокола.
  Вдобавок к статус-коду ответа также отправляется описание статуса, благодаря которому интуитивно понятно, что значит
  конкретный статус.
  HTTP-протокол очень практичен: в нем предусмотрено большое количество хедеров, используя которые можно настроить
  гибкое
  общение между клиентом и сервером. Все хедеры запросов и ответов, методы запросов и статус-коды ответов невозможно
  рассмотреть в одной статье. При необходимости можешь почитать официальную спецификацию протокола, которая описывает
  все
  нюансы.

HTTP-протокол принято использовать на порту 80, поэтому при работе с адресом, который заканчивается портом 80, можно
быть уверенным, что к нему нужно обращаться по HTTP.

С развитием технологий и активным перемещением персональных данных в интернет пришлось задуматься о том, как обеспечить
дополнительную защиту информации, которую клиент передает серверу. В результате появился протокол HTTPS. HTTPS
синтаксически идентичен протоколу HTTP, то есть использует те же стартовые строки и заголовки. Единственные отличия —
дополнительное шифрование и порт по умолчанию (443).

## Java Servlets

Java Servlet API — стандартизированный API, предназначенный для реализации на сервере и работе с клиентом по схеме
запрос-ответ.

Сервлет — это класс, который умеет получать запросы от клиента и возвращать ему ответы. Сервлеты в Java — именно те
элементы, с помощью которых строится клиент-серверная архитектура. Они работают в контексте веб-контейнера, такого как
Apache Tomcat или Jetty, и принимают HTTP-запросы от клиента, обрабатывают их и отправляют обратно HTTP-ответы.

Жизненный цикл сервлета Java включает в себя несколько этапов:
1. Инициализация: Сервлет инициализируется веб-контейнером при его первом вызове или при запуске контейнера.
2. Обработка запроса (Request Handling): Каждый раз, когда сервлет получает HTTP-запрос от клиента, он вызывает метод
`service()`, который затем вызывает метод `doGet()`, `doPost()`, `doPut()` или `doDelete()` в зависимости от типа
запроса. Разработчик должен переопределить соответствующий метод для обработки запроса.
3. Генерация ответа (Response Generation): Сервлет генерирует HTTP-ответ на основе полученного запроса. Ответ может быть
HTML-страницей, JSON-данными или любым другим типом данных, в зависимости от логики приложения.
4. Уничтожение (Destruction): При завершении работы веб-контейнера или перезапуске приложения вызывается метод 
`destroy()`, который позволяет освободить ресурсы, занятые сервлетом.
