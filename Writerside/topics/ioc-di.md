# Инверсия контроля и внедрение зависимостей

Модель программирования, принятая в Jakarta EE, позволяет разработчику сосредоточиться именно на том, на чем требуется –
то есть, на бизнес-логике. Больше не требуется наследовать классы API; разработчик может излагать логику своей
предметной области на обычном языке Java и преимущественно декларативно (при помощи аннотаций) управлять поведением
сервера приложений. Таким образом, фреймворк гладко интегрируется в ваш код и, в сущности, его столь же легко оттуда
убрать. При проектировании рассчитывайте не на переиспользование, а на легкое удаление.

Внедрение зависимостей (Dependency injection, DI) — это стиль настройки объекта, при котором поля объекта задаются
внешней сущностью. Другими словами, объекты настраиваются внешними объектами. DI — это альтернатива самонастройке
объектов. Данная практика заключается в том, чтобы передавать объекты, необходимые для работы определенного компонента
или модуля, через внешний механизм, такой как конструктор, метод или свойство, вместо того, чтобы создавать эти объекты
внутри компонента. Это позволяет сделать компоненты более независимыми и переиспользуемыми. Вместо того чтобы
привязывать компоненты к конкретным реализациям, они зависят от абстракций. Это делает их более гибкими и облегчает их
тестирование. Внедрение зависимостей также способствует улучшению читаемости кода и его поддержке. Когда зависимости
явно передаются в компонент, это делает понятным, какие ресурсы используются, и позволяет быстро понять, какие внешние
компоненты взаимодействуют с данным.

Инверсия контроля (Inversion of Control, IoC) - это принцип разработки программного обеспечения, который предполагает,
что управление потоком выполнения не осуществляется напрямую компонентами системы, а делегируется внешнему фреймворку
или контейнеру.

В контексте IoC контейнер (например, контейнер внедрения зависимостей) принимает на себя ответственность за создание и
управление объектами и их зависимостями. Вместо того чтобы компоненты самостоятельно создавать или получать свои
зависимости, они сообщают контейнеру о своих потребностях, и контейнер внедряет эти зависимости при необходимости.

Этот подход позволяет уменьшить связанность (coupling) между компонентами системы, так как компоненты не обязаны
заботиться о том, как создавать или настраивать свои зависимости. Они просто объявляют свои зависимости, и контейнер IoC
берет на себя заботу об их управлении.

## Инверсия контроля при использовании Jakarta {collapsible="true"}

В Jakarta EE компоненты представляют собой модули приложения, такие как сервлеты, EJB (Enterprise JavaBeans), CDI (
Contexts and Dependency Injection), JPA (Java Persistence API) и другие. Эти компоненты обеспечивают бизнес-логику,
управление данными, взаимодействие с пользователем и другие аспекты приложения.

Контейнер Jakarta EE:
: Контейнер Jakarta EE является рантайм-средой, которая управляет жизненным циклом и выполнением компонентов
приложения. Он обеспечивает инфраструктуру для создания, управления и взаимодействия с компонентами. Контейнеры могут
быть различными для различных типов компонентов, таких как контейнер сервлетов, EJB-контейнер, контейнер CDI и т.д.

Механизмы инверсии контроля в Jakarta EE:

* Аннотации:
  В Jakarta EE используются аннотации для указания контейнеру о конфигурации компонентов и их зависимостях. Например,
  аннотация @Inject используется для указания контейнеру, что компоненту нужно внедрить зависимость.

```
public class MyService {
@Inject
private MyDependency dependency;
// ...
}
```

* Конфигурационные файлы:
  Для настройки компонентов Jakarta EE можно использовать специальные XML-файлы, такие, как web.xml для веб-компонентов
  (например, сервлетов) и ejb-jar.xml для EJB-компонентов. Эти файлы позволяют определить, какие компоненты должны быть
  созданы и как они должны быть настроены.

* Контейнеры и управление жизненным циклом:
  Контейнер Jakarta EE берет на себя ответственность за создание, управление и уничтожение компонентов в соответствии с
  их
  жизненным циклом. Например, контейнер сервлетов создает экземпляры сервлетов при необходимости и уничтожает их, когда
  они больше не нужны.

Пример использования IoC с помощью CDI в Jakarta EE для внедрения зависимости:

```
public class MyService {
@Inject
private MyDependency dependency;

    public void doSomething() {
        dependency.doSomethingElse();
    }

}
```

В этом примере MyService объявляет зависимость от MyDependency с помощью аннотации @Inject. При выполнении приложения
контейнер CDI будет внедрять экземпляр MyDependency в MyService.

## Аннотации Jakarta EE {collapsible="true"}

1. @Stateless:
   @Stateless - это аннотация, которая используется для обозначения класса как EJB-компонента не хранящего состояние
   клиента между вызовами. Такой компонент создается и уничтожается контейнером EJB по мере необходимости.
   ```
   @Stateless
   public class MyStatelessBean {
   }
   ```

2. @Inject:
   @Inject используется для внедрения зависимостей в компоненты. Эта аннотация сообщает контейнеру, что компонент
   нуждается в экземпляре указанного типа.
   ```
    @Stateless
    public class MyStatelessBean {
    @Inject
    private MyDependency dependency;
    }
    ```

3. @Named:
   @Named используется для именования компонентов, которые будут использоваться в EL (Expression Language), например, в
   JSF (JavaServer Faces).

    ```
    @Named("myBean")
    @RequestScoped
    public class MyBean {
    // Бизнес-методы
    }
    ```
4. @PersistenceContext:
   @PersistenceContext используется для внедрения EntityManager в компоненты, работающие с базой данных через JPA (Java
   Persistence API).

    ```
    @Stateless
    public class MyStatelessBean {
    @PersistenceContext
    private EntityManager entityManager;
    }
    ``` 

## Dependency Lookup {collapsible="true"}

Dependency Lookup
: это механизм, который позволяет компонентам самостоятельно запрашивать зависимости из контейнера вместо того, чтобы
они были внедрены автоматически. В Jakarta EE это часто используется с помощью JNDI (Java Naming and Directory
Interface).

```
    public class MyBean {
    public void doSomething() {
    InitialContext ctx = new InitialContext();
    MyDependency dependency = (MyDependency) ctx.lookup("java:global/app/MyDependency");
    // использование зависимости
    }
    }   
   ```

## Контроль знаний

1. Что такое инверсия контроля и для чего она нужна?
2. Как инверсия контроля реализована в Jakarta EE и какие конфигурационные файлы нужны для ее настройки?
3. Что такое внедрение зависимостей?
4. Перечислить и описать аннотации, применяемые для внедрения зависимостей в Jakarta EE.
5. Что такое Dependency Lookup?